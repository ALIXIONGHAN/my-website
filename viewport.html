<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>è´ªåƒè›‡ â€” è›‡å¤´â€œèâ€ï¼Œé£Ÿç‰© ğŸ»</title>
  <style>
    html,body{height:100%;margin:0;font-family:system-ui,-apple-system,"Segoe UI",Roboto,'Microsoft YaHei',sans-serif;background:#111;color:#eee}
    .wrap{height:100%;display:flex;align-items:center;justify-content:center;flex-direction:column;gap:12px}
    canvas{background:#0b2a1a;border:6px solid #083;box-shadow:0 6px 20px rgba(0,0,0,0.6)}
    .info{display:flex;gap:12px;align-items:center}
    .hint{font-size:14px;opacity:0.9}
    .controls{font-size:13px;color:#ddd}
    .overlay{position:absolute;left:0;top:0;width:100%;height:100%;display:flex;align-items:center;justify-content:center}
    .panel{background:rgba(0,0,0,0.6);padding:18px;border-radius:10px;text-align:center}
    button{padding:8px 14px;border-radius:6px;border:0;background:#0b5;color:#023;font-weight:600;cursor:pointer}
  </style>
</head>
<body>
  <div class="wrap">
    <h2 style="margin:0">è´ªåƒè›‡ â€” è›‡å¤´ä¸ºâ€œèâ€ï¼Œé£Ÿç‰©ä¸º ğŸ»</h2>
    <div class="info">
      <div class="hint">åˆ†æ•°: <span id="score">0</span></div>
      <div class="hint">é€Ÿåº¦: <span id="speedLabel">ä¸­</span></div>
      <div class="controls">æ–¹å‘é”® / WASD æ§åˆ¶ï¼Œç©ºæ ¼ æš‚åœï¼ŒR é‡å¼€</div>
    </div>
    <div style="position:relative">
      <canvas id="game" width="480" height="480"></canvas>
      <div id="overlay" class="overlay" style="display:none">
        <div class="panel">
          <div id="msg" style="font-size:20px;margin-bottom:10px">æ¸¸æˆç»“æŸ</div>
          <div style="margin-bottom:10px">æœ€ç»ˆå¾—åˆ†: <span id="finalScore">0</span></div>
          <button id="restart">é‡æ–°å¼€å§‹ (R)</button>
        </div>
      </div>
    </div>
    <div style="font-size:13px;color:#aaa;max-width:640px;text-align:center">
      è¯´æ˜ï¼šè¿™æ˜¯å•æ–‡ä»¶ç¤ºä¾‹ã€‚è›‡å¤´ç”¨æ±‰å­—â€œèâ€è¡¨ç¤ºï¼Œé£Ÿç‰©ç”¨ç†ŠçŒ«è¡¨æƒ…â€œğŸ»â€ã€‚æ’å¢™æˆ–æ’åˆ°è‡ªå·±åˆ™æ¸¸æˆç»“æŸã€‚
    </div>
  </div>

<script>
(() => {
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');
  const scoreEl = document.getElementById('score');
  const finalScoreEl = document.getElementById('finalScore');
  const overlay = document.getElementById('overlay');
  const msg = document.getElementById('msg');
  const restartBtn = document.getElementById('restart');
  const speedLabel = document.getElementById('speedLabel');

  const CELL = 24; // æ ¼å­åƒç´ 
  const COLS = Math.floor(canvas.width / CELL);
  const ROWS = Math.floor(canvas.height / CELL);

  let snake = [];
  let dir = {x:1,y:0};
  let nextDir = null;
  let food = null;
  let running = false;
  let timer = null;
  let interval = 220; // æ¯«ç§’ï¼Œè¶Šå°è¶Šå¿«
  let score = 0;

  function reset(){
    snake = [ {x: Math.floor(COLS/2)-1, y: Math.floor(ROWS/2)}, {x: Math.floor(COLS/2)-2, y: Math.floor(ROWS/2)}, {x: Math.floor(COLS/2)-3, y: Math.floor(ROWS/2)} ];
    dir = {x:1,y:0};
    nextDir = null;
    placeFood();
    score = 0;
    scoreEl.textContent = score;
    setSpeedLabel();
    running = true;
    overlay.style.display = 'none';
    restartLoop();
    draw();
  }

  function setSpeedLabel(){
    if(interval <= 90) speedLabel.textContent = 'å¿«';
    else if(interval <= 140) speedLabel.textContent = 'ä¸­';
    else speedLabel.textContent = 'æ…¢';
  }

  function placeFood(){
    while(true){
      const x = Math.floor(Math.random()*COLS);
      const y = Math.floor(Math.random()*ROWS);
      if(!snake.some(s=>s.x===x && s.y===y)){
        food = {x,y};
        return;
      }
    }
  }

  function restartLoop(){
    if(timer) clearInterval(timer);
    timer = setInterval(tick, interval);
  }

  function tick(){
    // apply buffered direction
    if(nextDir){
      if(!(nextDir.x === -dir.x && nextDir.y === -dir.y)){
        dir = nextDir;
      }
      nextDir = null;
    }

    const head = {x: snake[0].x + dir.x, y: snake[0].y + dir.y};

    // è¾¹ç•Œæ£€æµ‹ï¼šæ’å¢™ç»“æŸ
    if(head.x < 0 || head.x >= COLS || head.y < 0 || head.y >= ROWS){
      gameOver('æ’å¢™äº†');
      return;
    }

    // ç¢°åˆ°è‡ªå·±
    if(snake.some(s=>s.x===head.x && s.y===head.y)){
      gameOver('å’¬åˆ°è‡ªå·±äº†');
      return;
    }

    snake.unshift(head);

    // åƒåˆ°é£Ÿç‰©
    if(head.x === food.x && head.y === food.y){
      score += 10;
      scoreEl.textContent = score;
      // æ¯åƒåˆ°ä¸€å®šæ•°é‡åŠ é€Ÿ
      interval = Math.max(60, Math.floor(interval * 0.95));
      setSpeedLabel();
      placeFood();
      restartLoop();
    } else {
      snake.pop();
    }

    draw();
  }

  function gameOver(reason){
    running = false;
    clearInterval(timer);
    msg.textContent = 'æ¸¸æˆç»“æŸ â€” ' + reason;
    finalScoreEl.textContent = score;
    overlay.style.display = 'flex';
  }

  function drawGrid(){
    // optional grid (subtle)
    ctx.save();
    ctx.strokeStyle = 'rgba(255,255,255,0.03)';
    for(let x=0;x<=COLS;x++){
      ctx.beginPath();ctx.moveTo(x*CELL,0);ctx.lineTo(x*CELL,ROWS*CELL);ctx.stroke();
    }
    for(let y=0;y<=ROWS;y++){
      ctx.beginPath();ctx.moveTo(0,y*CELL);ctx.lineTo(COLS*CELL,y*CELL);ctx.stroke();
    }
    ctx.restore();
  }

  function draw(){
    // èƒŒæ™¯
    ctx.clearRect(0,0,canvas.width,canvas.height);

    // grid
    drawGrid();

    // draw food (ç”¨ emoji)
    ctx.save();
    // è®© emoji æ˜¾ç¤ºè¾ƒå¤§ï¼šfont size 0.9*CELL
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.font = Math.floor(CELL*0.9) + 'px sans-serif';
    ctx.fillText('ğŸ»', food.x*CELL + CELL/2, food.y*CELL + CELL/2);
    ctx.restore();

    // draw snake body (ä»å°¾éƒ¨åˆ°å¤´éƒ¨)
    for(let i=snake.length-1;i>=1;i--){
      const s = snake[i];
      ctx.fillStyle = '#3b7';
      roundRect(ctx, s.x*CELL+1, s.y*CELL+1, CELL-2, CELL-2, 6, true, false);
    }

    // draw head as æ±‰å­—â€œèâ€
    const head = snake[0];
    ctx.save();
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    // head èƒŒæ™¯
    ctx.fillStyle = '#76e';
    roundRect(ctx, head.x*CELL+1, head.y*CELL+1, CELL-2, CELL-2, 6, true, false);
    // å­—ä½“è¦ç«–ç›´å±…ä¸­ï¼Œä½¿ç”¨ç¨å°äºCELLçš„å­—å·
    ctx.fillStyle = '#001';
    ctx.font = Math.floor(CELL*0.7) + 'px "Microsoft YaHei", sans-serif';
    ctx.fillText('è', head.x*CELL + CELL/2, head.y*CELL + CELL/2 + 1);
    ctx.restore();
  }

  function roundRect(ctx, x, y, w, h, r, fill, stroke) {
    if (typeof r === 'undefined') r = 5;
    ctx.beginPath();
    ctx.moveTo(x + r, y);
    ctx.arcTo(x + w, y, x + w, y + h, r);
    ctx.arcTo(x + w, y + h, x, y + h, r);
    ctx.arcTo(x, y + h, x, y, r);
    ctx.arcTo(x, y, x + w, y, r);
    ctx.closePath();
    if (fill) ctx.fill();
    if (stroke) ctx.stroke();
  }

  // input handling
  window.addEventListener('keydown', (e) => {
    const key = e.key;
    if(['ArrowUp','ArrowDown','ArrowLeft','ArrowRight','w','a','s','d','W','A','S','D'].includes(key)){
      e.preventDefault();
    }
    if(key === 'ArrowUp' || key === 'w' || key === 'W') nextDir = {x:0,y:-1};
    if(key === 'ArrowDown' || key === 's' || key === 'S') nextDir = {x:0,y:1};
    if(key === 'ArrowLeft' || key === 'a' || key === 'A') nextDir = {x:-1,y:0};
    if(key === 'ArrowRight' || key === 'd' || key === 'D') nextDir = {x:1,y:0};

    if(key === ' '){ // ç©ºæ ¼ æš‚åœ/ç»§ç»­
      if(running){ clearInterval(timer); running = false; overlay.style.display = 'flex'; msg.textContent = 'å·²æš‚åœ'; finalScoreEl.textContent = score; }
      else { overlay.style.display = 'none'; running = true; restartLoop(); }
    }
    if(key === 'r' || key === 'R'){
      reset();
    }
  });

  restartBtn.addEventListener('click', reset);

  // åˆå§‹
  reset();
})();
</script>
</body>
</html>
